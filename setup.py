#!/usr/bin/env python3
"""
API Scanner setup script.

Generates secure passwords, writes .env configuration, and optionally
starts the Docker Compose stack.

Requirements: Python 3.6+, Docker with Compose v2.
No third-party dependencies.
"""

import os
import secrets
import shutil
import string
import subprocess
import sys

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ENV_FILE = os.path.join(SCRIPT_DIR, ".env")
COMPOSE_FILE = os.path.join(SCRIPT_DIR, "docker-compose.yml")

ALPHABET = string.ascii_letters + string.digits


def generate_password(length: int) -> str:
    return "".join(secrets.choice(ALPHABET) for _ in range(length))


def check_python_version() -> None:
    if sys.version_info < (3, 6):
        print("Error: Python 3.6 or later is required.")
        sys.exit(1)


def check_command(args: list) -> bool:
    try:
        subprocess.run(
            args,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        return True
    except FileNotFoundError:
        return False


def check_prerequisites() -> None:
    check_python_version()

    if not shutil.which("docker"):
        print("Error: 'docker' not found. Install Docker first.")
        sys.exit(1)

    if not check_command(["docker", "compose", "version"]):
        print("Error: 'docker compose' not available. Install Docker Compose v2.")
        sys.exit(1)

    if not os.path.isfile(COMPOSE_FILE):
        print(f"Error: docker-compose.yml not found at {COMPOSE_FILE}")
        print("Run this script from the deployment directory.")
        sys.exit(1)


def detect_timezone() -> str:
    # /etc/timezone (Debian/Ubuntu)
    try:
        with open("/etc/timezone") as f:
            tz = f.read().strip()
            if tz:
                return tz
    except OSError:
        pass

    # /etc/localtime symlink (Linux/macOS)
    try:
        link = os.path.realpath("/etc/localtime")
        marker = "zoneinfo/"
        idx = link.find(marker)
        if idx != -1:
            return link[idx + len(marker):]
    except OSError:
        pass

    return "UTC"


def confirm(question: str, default_yes: bool = False) -> bool:
    hint = "[Y/n]" if default_yes else "[y/N]"
    try:
        response = input(f"{question} {hint}: ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        print()
        return False
    if not response:
        return default_yes
    return response in ("y", "yes")


def build_env_content(passwords: dict, settings: dict) -> str:
    database_uri = (
        f"api_scanner:{passwords['MARIADB_PASSWORD']}"
        f"@tcp(mariadb:3306)/api_db?parseTime=True"
    )
    mongo_database_uri = (
        f"mongodb://apiscan_user:{passwords['MONGO_APP_PASSWORD']}"
        f"@mongodb:27017/apiscan_db?authMechanism=SCRAM-SHA-256"
    )

    lines = [
        "# =============================================================================",
        "# API Scanner Configuration",
        "# Generated by setup.py — do not commit this file",
        "# =============================================================================",
        "",
        "# --- MariaDB ---",
        f"MARIADB_ROOT_PASSWORD={passwords['MARIADB_ROOT_PASSWORD']}",
        "MARIADB_USER=api_scanner",
        f"MARIADB_PASSWORD={passwords['MARIADB_PASSWORD']}",
        "MARIADB_DATABASE=api_db",
        "",
        "# --- MongoDB ---",
        "MONGO_ROOT_USERNAME=root",
        f"MONGO_ROOT_PASSWORD={passwords['MONGO_ROOT_PASSWORD']}",
        "MONGO_DATABASE=apiscan_db",
        "MONGO_APP_USERNAME=apiscan_user",
        f"MONGO_APP_PASSWORD={passwords['MONGO_APP_PASSWORD']}",
        "",
        "# --- API Scanner ---",
        "SERVER_ADDRESS=0.0.0.0:443",
        "USE_TLS=true",
        "CERT_PATH=/app/certs/cert.pem",
        "KEY_PATH=/app/certs/key.pem",
        f"CSRF_KEY={passwords['CSRF_KEY']}",
        "CSRF_NAME=csrf_token",
        "ALLOWED_INTERNAL_HOSTS=localhost,127.0.0.1,api-scanner",
        f"TRUSTED_ORIGINS={settings['TRUSTED_ORIGINS']}",
        "",
        "DBMS_TYPE=mysql",
        "# Note: 'mariadb' here refers to the docker-compose service name",
        f"DATABASE_URI={database_uri}",
        "MIGRATIONS_PREFIX=/app/db/migrations",
        "",
        f"PRODUCT_TITLE={settings['PRODUCT_TITLE']}",
        f"COPYRIGHT_FOOTER_COMPANY={settings['COPYRIGHT_FOOTER_COMPANY']}",
        f"CONTACT_ADDRESS={settings['CONTACT_ADDRESS']}",
        "",
        "# Note: 'mongodb' here refers to the docker-compose service name",
        f"MONGO_DATABASE_URI={mongo_database_uri}",
        "MONGO_DATABASE_NAME=apiscan_db",
        "",
        "WORK_DIR=/app/data/work_dir",
        "TEMP_UPLOADS_DIR=/app/data/temp_uploads",
        "",
        "LOG_LEVEL=info",
        "LOG_FILENAME=/app/logs/app.log",
        "",
        "# Required by manager config but unused in Docker mode",
        "SCANNER_DOCKER=unused",
        "FUZZER_IMAGE=unused",
        "MAIN_DOMAIN=localhost",
        "",
        "# Required by panel config but unused in community edition",
        "LICENSE_VALIDATION_API=http://localhost",
        "",
        "# Note: 'zap' here refers to the docker-compose service name",
        "ZAP_HOST=zap",
        "ZAP_PORT=8080",
        f"ZAP_API_KEY={passwords['ZAP_API_KEY']}",
        "",
        "REMOTE_WORK_DIR=/app/data/work_dir/",
        "LOCAL_TEMP_DIR=/app/data/temp/",
        "",
        "CATS_BIN_PATH=/app/bin/cats",
        "REPORTER_BIN_PATH=/app/bin/reporter",
        "SCANNER_CMD=/app/bin/scanner",
        "",
        "# --- Timezone ---",
        f"TZ={settings['TZ']}",
    ]
    return "\n".join(lines) + "\n"


def print_summary(passwords: dict, timezone: str) -> None:
    print("\n" + "=" * 60)
    print("  Configuration Summary")
    print("=" * 60)

    print("\n  Generated credentials (save these somewhere safe):\n")
    col = max(len(k) for k in passwords) + 2
    for key, value in passwords.items():
        print(f"    {key:<{col}} {value}")

    print(f"\n  Timezone: {timezone}")

    print("\n" + "=" * 60)
    print(f"  .env written to: {ENV_FILE}")
    print("=" * 60)


def ensure_tls_certs() -> None:
    certs_dir = os.path.join(SCRIPT_DIR, "certs")
    cert_file = os.path.join(certs_dir, "cert.pem")
    key_file = os.path.join(certs_dir, "key.pem")

    if os.path.isfile(cert_file) and os.path.isfile(key_file):
        return

    print("\nNo TLS certificates found in ./certs/")

    if not shutil.which("openssl"):
        print("'openssl' not found — cannot generate a self-signed certificate.")
        print("Please place cert.pem and key.pem in ./certs/ manually.")
        return

    if not confirm("Generate a self-signed certificate for localhost?", default_yes=True):
        print("Skipped. Place cert.pem and key.pem in ./certs/ before starting.")
        return

    os.makedirs(certs_dir, exist_ok=True)
    result = subprocess.run(
        [
            "openssl", "req", "-x509",
            "-newkey", "rsa:4096",
            "-keyout", key_file,
            "-out", cert_file,
            "-days", "365",
            "-nodes",
            "-subj", "/CN=localhost",
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
    )
    if result.returncode == 0:
        print("Self-signed certificate generated in ./certs/")
    else:
        print("Failed to generate certificate:")
        print(result.stderr.decode())


def start_stack() -> None:
    print("\nStarting Docker Compose stack...")
    result = subprocess.run(
        ["docker", "compose", "up", "-d"],
        cwd=SCRIPT_DIR,
    )
    if result.returncode == 0:
        print("\nStack started successfully!")
        print("Access the panel at: https://localhost:4455")
        print(
            "\nNote: On first start, databases may take 30-60 seconds to initialize."
        )
        print("If using self-signed certs, your browser will show a security warning.")
    else:
        print("\nFailed to start the stack. Check the output above for errors.")
        sys.exit(1)


def main() -> None:
    print("API Scanner Setup")
    print("-" * 40)

    check_prerequisites()
    print("Prerequisites OK.\n")

    if os.path.isfile(ENV_FILE):
        print(f"An .env file already exists at:\n  {ENV_FILE}\n")
        if not confirm("Overwrite it with a new configuration?"):
            print("Aborted.")
            sys.exit(0)
        print()

    # Generate secure passwords
    passwords = {
        "MARIADB_ROOT_PASSWORD": generate_password(24),
        "MARIADB_PASSWORD": generate_password(24),
        "MONGO_ROOT_PASSWORD": generate_password(24),
        "MONGO_APP_PASSWORD": generate_password(24),
        "CSRF_KEY": generate_password(32),
        "ZAP_API_KEY": generate_password(24),
    }

    settings = {
        "PRODUCT_TITLE": "API Scanner",
        "COPYRIGHT_FOOTER_COMPANY": "CySecurity Pte Ltd",
        "CONTACT_ADDRESS": "support@localhost",
        "TRUSTED_ORIGINS": "https://localhost:4455",
        "TZ": detect_timezone(),
    }

    content = build_env_content(passwords, settings)

    with open(ENV_FILE, "w") as f:
        f.write(content)

    print_summary(passwords, settings["TZ"])

    ensure_tls_certs()

    print()
    if confirm("Start the Docker Compose stack now?", default_yes=True):
        start_stack()
    else:
        print("\nTo start later, run:")
        print(f"  cd {SCRIPT_DIR}")
        print("  docker compose up -d")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nAborted.")
        sys.exit(1)
